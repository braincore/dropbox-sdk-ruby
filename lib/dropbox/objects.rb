# Generated by BabelSDK

# DO NOT EDIT THIS FILE.
# This file is auto-generated from the babel template objects.babelt.rb.
# Any changes here will silently disappear into nothingness.

require 'date'######
module Dropbox
  module API

    # Converts a string date to a Date object
    def self.convert_date(str)
      DateTime.strptime(str, '%a, %d %b %Y %H:%M:%S')
    end

    # Photo-specific information derived from EXIF data.
    #
    # Fields:
    # * +time_taken+ (+Timestamp+):
    #   When the photo was taken.
    # * +lat_long+ (+List+):
    #   The GPS coordinates where the photo was taken.
    class PhotoInfo
      attr_accessor(
          :time_taken,
          :lat_long
      )
    
      def initialize(
          time_taken,
          lat_long
      )
        @time_taken = time_taken
        @lat_long = lat_long
      end
    
      def self.from_json(json)
        self.new(
            Dropbox::API::convert_date(json['time_taken']),
            json['lat_long'].nil? ? nil : json['lat_long'],
        )
      end
    end
    
    # Video-specific information derived from EXIF data.
    #
    # Fields:
    # * +time_taken+ (+Timestamp+):
    #   When the photo was taken.
    # * +lat_long+ (+List+):
    #   The GPS coordinates where the photo was taken.
    # * +duration+ (+Float+):
    #   Length of video in milliseconds.
    class VideoInfo
      attr_accessor(
          :time_taken,
          :lat_long,
          :duration
      )
    
      def initialize(
          time_taken,
          lat_long,
          duration
      )
        @time_taken = time_taken
        @lat_long = lat_long
        @duration = duration
      end
    
      def self.from_json(json)
        self.new(
            Dropbox::API::convert_date(json['time_taken']),
            json['lat_long'].nil? ? nil : json['lat_long'],
            json['duration'],
        )
      end
    end
    
    # Media specific information.
    #
    # Fields:
    # * +audio+:
    #   Audio file.
    # * +photo+ (+PhotoInfo+)
    # * +video+ (+VideoInfo+)
    class MediaInfo
    
      TYPES = [:audio, :photo, :video]
    
      def initialize(key, val = nil)
        set(key, val)
      end
    
      def set(key, val = nil)
        if key.is_a?(String)
          key = key.to_sym
        end
        if key.is_a?(Symbol)
          if !TYPES.include?(key)
              fail ArgumentError, "Invalid symbol '#{ key }' for "\
                "this union. #{ TYPES }"
          end
        elsif key.is_a?(Hash)
          array = key.flatten
          if array.length != 2
            fail ArgumentError, 'Invalid JSON for this union.'
          end
          if !TYPES.include?(array[0].to_sym)
            fail ArgumentError, "Invalid key '#{ array[0] }' for this union."
          end
        else
          fail ArgumentError, "Argument must be a hash, string, or symbol."
        end
        @key = key
        @val = val
      end
    
      def value
        @val
      end
    
      def as_json(options = {})
        if @val.nil?
          @key.to_s
        else
          { @key => @val }
        end
      end
    
      def self.from_json(json)
        if json.is_a?(Hash)
          array = json.flatten
          if array.length != 2
            fail ArgumentError, "JSON should have one key/value pair."
          end
          key = array[0].to_sym
          if key == :audio
            val = nil
          end
          if key == :photo
            val = PhotoInfo.from_json(array[1])
          end
          if key == :video
            val = VideoInfo.from_json(array[1])
          end
        else
          # json is a String
          key = json.to_sym
          val = nil
        end
        return self.new(key, val)
      end
    
      def self.audio
        self.new(:audio)
      end
    
      def audio?
        @key == :audio
      end
    
      def audio
        fail "This field is a symbol field."
      end
    
      def self.photo
        self.new(:photo)
      end
    
      def photo?
        @key == :photo
      end
    
      def photo
        if @key == :photo
          @val
        else
          fail "Union is not this type."
        end
      end
    
      def self.video
        self.new(:video)
      end
    
      def video?
        @key == :video
      end
    
      def video
        if @key == :video
          @val
        else
          fail "Union is not this type."
        end
      end
    end
    # Blah.
    #
    # Fields:
    # * +id+ (+String+)
    class SharedFolder
      attr_accessor(
          :id
      )
    
      def initialize(
          id
      )
        @id = id
      end
    
      def self.from_json(json)
        self.new(
            json['id'],
        )
      end
    end
    
    # A file or folder entry.
    #
    # Fields:
    # * +id+ (+String+):
    #   A unique identifier for the file.
    # * +id_rev+ (+UInt64+):
    #   A unique identifier for the current revision of a file. This field is
    #   the same rev as elsewhere in the API and can be used to detect changes
    #   and avoid conflicts.
    # * +path+ (+String+):
    #   Path to file or folder.
    # * +shared_folder+ (+SharedFolder+):
    #   If this a shared folder, information about it.
    # * +modified+ (+Timestamp+):
    #   The last time the file was modified on Dropbox, in the standard
    #   Timestamp format (null for root folder).
    # * +is_deleted+ (+Boolean+):
    #   Whether the given entry is deleted.
    class EntryInfo
      attr_accessor(
          :id,
          :id_rev,
          :path,
          :shared_folder,
          :modified,
          :is_deleted
      )
    
      def initialize(
          id,
          id_rev,
          path,
          shared_folder,
          modified,
          is_deleted
      )
        @id = id
        @id_rev = id_rev
        @path = path
        @shared_folder = shared_folder
        @modified = modified
        @is_deleted = is_deleted
      end
    
      def self.from_json(json)
        self.new(
            json['id'],
            json['id_rev'],
            json['path'],
            json['shared_folder'].nil? ? nil : SharedFolder.from_json(json['shared_folder']),
            json['modified'].nil? ? nil : Dropbox::API::convert_date(json['modified']),
            json['is_deleted'],
        )
      end
    end
    
    # Describes a file.
    #
    # Fields:
    # * +id+ (+String+):
    #   A unique identifier for the file.
    # * +id_rev+ (+UInt64+):
    #   A unique identifier for the current revision of a file. This field is
    #   the same rev as elsewhere in the API and can be used to detect changes
    #   and avoid conflicts.
    # * +path+ (+String+):
    #   Path to file or folder.
    # * +shared_folder+ (+SharedFolder+):
    #   If this a shared folder, information about it.
    # * +modified+ (+Timestamp+):
    #   The last time the file was modified on Dropbox, in the standard
    #   Timestamp format (null for root folder).
    # * +is_deleted+ (+Boolean+):
    #   Whether the given entry is deleted.
    # * +size+ (+UInt64+):
    #   File size in bytes.
    # * +mime_type+ (+String+):
    #   The Internet media type determined by the file extension.
    # * +media_info+ (+MediaInfo+):
    #   Information specific to photo and video media.
    class FileInfo < EntryInfo
      attr_accessor(
          :size,
          :mime_type,
          :media_info
      )
    
      def initialize(
          id,
          id_rev,
          path,
          shared_folder,
          modified,
          is_deleted,
          size,
          mime_type,
          media_info
      )
        @id = id
        @id_rev = id_rev
        @path = path
        @shared_folder = shared_folder
        @modified = modified
        @is_deleted = is_deleted
        @size = size
        @mime_type = mime_type
        @media_info = media_info
      end
    
      def self.from_json(json)
        self.new(
            json['id'],
            json['id_rev'],
            json['path'],
            json['shared_folder'].nil? ? nil : SharedFolder.from_json(json['shared_folder']),
            json['modified'].nil? ? nil : Dropbox::API::convert_date(json['modified']),
            json['is_deleted'],
            json['size'],
            json['mime_type'].nil? ? nil : json['mime_type'],
            MediaInfo.from_json(json['media_info']),
        )
      end
    end
    
    # Describes a folder.
    #
    # Fields:
    # * +id+ (+String+):
    #   A unique identifier for the file.
    # * +id_rev+ (+UInt64+):
    #   A unique identifier for the current revision of a file. This field is
    #   the same rev as elsewhere in the API and can be used to detect changes
    #   and avoid conflicts.
    # * +path+ (+String+):
    #   Path to file or folder.
    # * +shared_folder+ (+SharedFolder+):
    #   If this a shared folder, information about it.
    # * +modified+ (+Timestamp+):
    #   The last time the file was modified on Dropbox, in the standard
    #   Timestamp format (null for root folder).
    # * +is_deleted+ (+Boolean+):
    #   Whether the given entry is deleted.
    class FolderInfo < EntryInfo
    
      def initialize(
          id,
          id_rev,
          path,
          shared_folder,
          modified,
          is_deleted
      )
        @id = id
        @id_rev = id_rev
        @path = path
        @shared_folder = shared_folder
        @modified = modified
        @is_deleted = is_deleted
      end
    
      def self.from_json(json)
        self.new(
            json['id'],
            json['id_rev'],
            json['path'],
            json['shared_folder'].nil? ? nil : SharedFolder.from_json(json['shared_folder']),
            json['modified'].nil? ? nil : Dropbox::API::convert_date(json['modified']),
            json['is_deleted'],
        )
      end
    end
    
    # A file or folder in a Dropbox.
    #
    # Fields:
    # * +file+ (+FileInfo+)
    # * +folder+ (+FolderInfo+)
    class FileOrFolderInfo
    
      TYPES = [:file, :folder]
    
      def initialize(key, val = nil)
        set(key, val)
      end
    
      def set(key, val = nil)
        if key.is_a?(String)
          key = key.to_sym
        end
        if key.is_a?(Symbol)
          if !TYPES.include?(key)
              fail ArgumentError, "Invalid symbol '#{ key }' for "\
                "this union. #{ TYPES }"
          end
        elsif key.is_a?(Hash)
          array = key.flatten
          if array.length != 2
            fail ArgumentError, 'Invalid JSON for this union.'
          end
          if !TYPES.include?(array[0].to_sym)
            fail ArgumentError, "Invalid key '#{ array[0] }' for this union."
          end
        else
          fail ArgumentError, "Argument must be a hash, string, or symbol."
        end
        @key = key
        @val = val
      end
    
      def value
        @val
      end
    
      def as_json(options = {})
        if @val.nil?
          @key.to_s
        else
          { @key => @val }
        end
      end
    
      def self.from_json(json)
        if json.is_a?(Hash)
          array = json.flatten
          if array.length != 2
            fail ArgumentError, "JSON should have one key/value pair."
          end
          key = array[0].to_sym
          if key == :file
            val = FileInfo.from_json(array[1])
          end
          if key == :folder
            val = FolderInfo.from_json(array[1])
          end
        else
          # json is a String
          key = json.to_sym
          val = nil
        end
        return self.new(key, val)
      end
    
      def self.file
        self.new(:file)
      end
    
      def file?
        @key == :file
      end
    
      def file
        if @key == :file
          @val
        else
          fail "Union is not this type."
        end
      end
    
      def self.folder
        self.new(:folder)
      end
    
      def folder?
        @key == :folder
      end
    
      def folder
        if @key == :folder
          @val
        else
          fail "Union is not this type."
        end
      end
    end
    
    
    # Header of a delta response.
    #
    # Fields:
    # * +reset+ (+Boolean+):
    #   If true, clear your local state before processing the delta entries.
    #   reset is always true on the initial call to /delta (i.e. when no
    #   cursor is passed in). Otherwise, it is true in rare situations, such
    #   as after server or account maintenance, or if a user deletes their app
    #   folder.
    # * +created+ (+Timestamp+):
    #   When file was created.
    class DeltaHeader
      attr_accessor(
          :reset,
          :created
      )
    
      def initialize(
          reset,
          created
      )
        @reset = reset
        @created = created
      end
    
      def self.from_json(json)
        self.new(
            json['reset'],
            Dropbox::API::convert_date(json['created']),
        )
      end
    end
    
    # Footer of a delta response. Stores values that can only be computed
    # after the final EntryInfo.
    # This is the next part of the doc.
    #
    # Fields:
    # * +cursor+ (+String+):
    #   A string that encodes the latest information that has been returned.
    #   On the next call to /delta, pass in this value.
    # * +has_more+ (+Boolean+):
    #   If true, then there are more entries available; you can call /delta
    #   again immediately to retrieve those entries. If 'false', then wait for
    #   at least five minutes (preferably longer) before checking again.
    class DeltaFooter
      attr_accessor(
          :cursor,
          :has_more
      )
    
      def initialize(
          cursor,
          has_more
      )
        @cursor = cursor
        @has_more = has_more
      end
    
      def self.from_json(json)
        self.new(
            json['cursor'],
            json['has_more'],
        )
      end
    end
    
    
    
    # On a write conflict, overwrite the existing file if the parent rev
    # matches.
    #
    # Fields:
    # * +parent_rev+ (+String+):
    #   The revision to be updated.
    # * +auto_rename+ (+Boolean+):
    #   Whether the new file should be renamed on a conflict.
    class UpdateParentRev
      attr_accessor(
          :parent_rev,
          :auto_rename
      )
    
      def initialize(
          parent_rev,
          auto_rename
      )
        @parent_rev = parent_rev
        @auto_rename = auto_rename
      end
    
      def self.from_json(json)
        self.new(
            json['parent_rev'],
            json['auto_rename'],
        )
      end
    end
    
    # Policy for managing write conflicts.
    #
    # Fields:
    # * +reject+:
    #   On a write conflict, reject the new file.
    # * +overwrite+:
    #   On a write conflict, overwrite the existing file.
    # * +rename+:
    #   On a write conflict, rename the new file with a numerical suffix.
    # * +update_if_matching_parent_rev+ (+UpdateParentRev+):
    #   On a write conflict, overwrite the existing file.
    class WriteConflictPolicy
    
      TYPES = [:reject, :overwrite, :rename, :update_if_matching_parent_rev]
    
      def initialize(key, val = nil)
        set(key, val)
      end
    
      def set(key, val = nil)
        if key.is_a?(String)
          key = key.to_sym
        end
        if key.is_a?(Symbol)
          if !TYPES.include?(key)
              fail ArgumentError, "Invalid symbol '#{ key }' for "\
                "this union. #{ TYPES }"
          end
        elsif key.is_a?(Hash)
          array = key.flatten
          if array.length != 2
            fail ArgumentError, 'Invalid JSON for this union.'
          end
          if !TYPES.include?(array[0].to_sym)
            fail ArgumentError, "Invalid key '#{ array[0] }' for this union."
          end
        else
          fail ArgumentError, "Argument must be a hash, string, or symbol."
        end
        @key = key
        @val = val
      end
    
      def value
        @val
      end
    
      def as_json(options = {})
        if @val.nil?
          @key.to_s
        else
          { @key => @val }
        end
      end
    
      def self.from_json(json)
        if json.is_a?(Hash)
          array = json.flatten
          if array.length != 2
            fail ArgumentError, "JSON should have one key/value pair."
          end
          key = array[0].to_sym
          if key == :reject
            val = nil
          end
          if key == :overwrite
            val = nil
          end
          if key == :rename
            val = nil
          end
          if key == :update_if_matching_parent_rev
            val = UpdateParentRev.from_json(array[1])
          end
        else
          # json is a String
          key = json.to_sym
          val = nil
        end
        return self.new(key, val)
      end
    
      def self.reject
        self.new(:reject)
      end
    
      def reject?
        @key == :reject
      end
    
      def reject
        fail "This field is a symbol field."
      end
    
      def self.overwrite
        self.new(:overwrite)
      end
    
      def overwrite?
        @key == :overwrite
      end
    
      def overwrite
        fail "This field is a symbol field."
      end
    
      def self.rename
        self.new(:rename)
      end
    
      def rename?
        @key == :rename
      end
    
      def rename
        fail "This field is a symbol field."
      end
    
      def self.update_if_matching_parent_rev
        self.new(:update_if_matching_parent_rev)
      end
    
      def update_if_matching_parent_rev?
        @key == :update_if_matching_parent_rev
      end
    
      def update_if_matching_parent_rev
        if @key == :update_if_matching_parent_rev
          @val
        else
          fail "Union is not this type."
        end
      end
    end
    
    
    # The space quota info for a user.
    #
    # Fields:
    # * +quota+ (+UInt64+):
    #   The user's total quota allocation (bytes).
    # * +normal+ (+UInt64+):
    #   The user's used quota outside of shared folders (bytes).
    # * +shared+ (+UInt64+):
    #   The user's used quota in shared folders (bytes).
    class QuotaInfo
      attr_accessor(
          :quota,
          :normal,
          :shared
      )
    
      def initialize(
          quota,
          normal,
          shared
      )
        @quota = quota
        @normal = normal
        @shared = shared
      end
    
      def self.from_json(json)
        self.new(
            json['quota'],
            json['normal'],
            json['shared'],
        )
      end
    end
    
    # Information relevant to a team.
    #
    # Fields:
    # * +name+ (+String+):
    #   The name of the team.
    class Team
      attr_accessor(
          :name
      )
    
      def initialize(
          name
      )
        @name = name
      end
    
      def self.from_json(json)
        self.new(
            json['name'],
        )
      end
    end
    
    # Information for a user's account.
    #
    # Fields:
    # * +display_name+ (+String+):
    #   The full name of a user.
    # * +quota+ (+QuotaInfo+):
    #   The user's quota.
    # * +is_paired+ (+Boolean+):
    #   Whether the user has a personal and business account.
    # * +team+ (+Team+):
    #   If this paired account is a member of a team.
    class AccountInfo
      attr_accessor(
          :display_name,
          :quota,
          :is_paired,
          :team
      )
    
      def initialize(
          display_name,
          quota,
          is_paired,
          team
      )
        @display_name = display_name
        @quota = quota
        @is_paired = is_paired
        @team = team
      end
    
      def self.from_json(json)
        self.new(
            json['display_name'],
            QuotaInfo.from_json(json['quota']),
            json['is_paired'],
            json['team'].nil? ? nil : Team.from_json(json['team']),
        )
      end
    end
    
    
  end
end