# babelsdk(jinja2)

# DO NOT EDIT THIS FILE.
# This file is auto-generated from the babel template client.babelt.rb.
# Any changes here will silently disappear.
{# TODO If extras['host'] ends up not used, can use this instead: #}
{#% if 'Binary' in op.response_segmentation.segments|map(attribute='data_type')|map(attribute='name') %#}

{%- macro struct_doc_ref(s) -%}
Dropbox::API::{{ s|class }}
{%- endmacro -%}

{%- macro op_doc_ref(s) -%}
Dropbox::API::Client::Files.{{ s|method }}`
{%- endmacro -%}

{%- macro field_doc_ref(s) -%}
{{ s }}
{%- endmacro -%}

{%- macro link_doc_ref(s) -%}
{{ s }}
{%- endmacro -%}

{%- macro val_doc_ref(s) -%}
{%- if s == 'True' -%}
+true+
{%- elif s == 'False' -%}
+false+
{%- elif s == 'null' -%}
+nil+
{%- endif -%}
{%- endmacro -%}

{%- macro ruby_doc_sub(s) -%}
{{ s|doc_sub(struct=struct_doc_ref, op=op_doc_ref, field=field_doc_ref, link=link_doc_ref, val=val_doc_ref) }}
{%- endmacro -%}

{%- macro required_arg_list(args) -%}
{%- for arg in args -%}
{{ arg.name }}{% if arg.has_default %} = {{ arg.default|pprint }}{% endif %},{{ ' ' }}
{%- endfor -%}
{%- endmacro -%}

{%- macro arg_doc(fields) -%}
{% for field in fields %}
# * +{{ field.name }}+{{ typename(field) }}:{{ ' ' }}
{%- if field.has_default %}(defaults to {{ field.default|pprint }})
{% else %}{# blank block for a newline here #}

{% endif %}
#   {{ ruby_doc_sub(field.doc)|wordwrap(70)|replace('\n', '\n#   ') }}
{% endfor %}
{%- endmacro -%}

{%- macro host(op) -%}
{%- if op.extras['host'] == 'content' -%}
@host_info.api_content_server
{%- else -%}
@host_info.api_server
{%- endif -%}
{%- endmacro -%}

{%- macro input_binary(op) -%}
{%- if op.extras['host'] == 'content' -%}
{%- for segment in op.request_segmentation.segments -%}
{%- if segment.data_type.name == 'Binary' -%}
, {{ segment.name|variable }}
{%- endif -%}
{%- endfor -%}
{%- endif -%}
{%- endmacro -%}

{%- macro endpoint(op) -%}
{%- if op.extras['host'] == 'content' -%}
do_content_endpoint
{%- else -%}
do_rpc_endpoint
{%- endif -%}
{%- endmacro -%}

{%- macro handle_response(op, indent_spaces) %}
{% filter indent(indent_spaces) %}
{% if op.extras['host'] == 'content' %}
file, metadata = Dropbox::API::HTTP.parse_content_response(response)
return file, Dropbox::API::{{ op.response_segmentation.segments[0].data_type.name|class }}{%- trim -%}
    .from_json(metadata)
{% else %}
# If this is a multi-part response, this won't work yet.
Dropbox::API::{{ op.response_segmentation.segments[0].data_type.name|class }}{%- trim -%}
    .from_json(Dropbox::API::HTTP.parse_rpc_response(response))
{% endif %}
{% endfilter %}
{% endmacro %}

{%- macro typename(field) %}
{%- if field.data_type.composite_type -%}
{{ ' ' }}(+{{ field.data_type.name|class }}+)
{%- else -%}
{{ ' ' }}(+{{ field.data_type|type }}+)
{%- endif -%}
{%- endmacro -%}

{%- macro namespace_def(namespace_name, namespace, indent_spaces) %}
{% filter indent(indent_spaces) %}
class {{ namespace_name|class }} < EndpointNamespace
  def initialize(session)
    super(session)
    @namespace = '{{ namespace_name|variable }}'
  end

  {% for op in namespace.operations %}
  {{ operation_def(op, 2) }}
  {% endfor %}
end

{% endfilter %}
{% endmacro %}

{%- macro operation_def(op, indent_spaces) -%}
{% filter indent(indent_spaces) %}
{% set request_segment = op.request_segmentation.segments[0].data_type %}
# {{ ruby_doc_sub(op.doc)|wordwrap(70)|replace('\n', '\n# ') }}
#
# Required args:
{{ arg_doc(request_segment.all_required_fields) -}}
{% if op.request_segmentation.segments[1] %}
# * +{{ op.request_segmentation.segments[1].name|variable }}+
{# TODO should we allow a string here? #}
#   File-like object
{% endif %}
{% if request_segment.all_optional_fields|length > 0 %}
#
# Optional args:
{{ arg_doc(request_segment.all_optional_fields) -}}
{% endif %}
#
# Returns:
#   {{ op.response_segmentation.segments[0].data_type.name|class }}
{# hack: assume there's only one input struct with an optional binary after it #}
{# hack: assume if there's more than one field in the response, then the first one is a struct and the second is binary #}
{# TODO add optional/nullable/default arguments #}
def {{ op.name|method }}({{ required_arg_list(request_segment.all_required_fields)|string_slice(0, -2) }}
    {%- if op.request_segmentation.segments[1] -%}
      , {{ op.request_segmentation.segments[1].name|variable }}
    {%- endif -%}
    {%- if request_segment.all_optional_fields|length > 0 -%}
      , opts = {}
    {%- endif -%})
  {% if request_segment.all_optional_fields|length > 0 %}
  optional_inputs = {
    {% for field in request_segment.all_optional_fields %}
      {% if field.has_default %}
    {{ field.name }}: {{ field.default|pprint }},
      {% endif %}
    {% endfor %}
  }.merge(opts)
  {% endif %}
  input_json = {
    {% for field in request_segment.all_fields %}
      {% if field.optional %}
    {{ field.name }}: optional_inputs[:{{ field.name }}],
      {% else %}
    {{ field.name }}: {{ field.name }},
      {% endif %}
    {% endfor %}
  }
  response = @session.{{ endpoint(op) }}({%- trim -%}
    "/#{ @namespace }/{{ op.name|lower }}", input_json{{ input_binary(op) }})
  {# hack: assume that a multi-part json response will be a single object for now #}
  {# TODO what if it's a list? #}
  {{ handle_response(op, 2) }}
end

{% endfilter %}
{% endmacro %}

module Dropbox
  module API

    # Use this class to make Dropbox API calls.  You'll need to obtain an
    # OAuth 2 access token first; you can get one using either WebAuth or
    # WebAuthNoRedirect.
    class Client

      attr_accessor {{ api.namespaces.keys()|map('inverse_format', ':{0}')|join(', ') }}

      # Args:
      # * +oauth2_access_token+: Obtained via WebAuth or WebAuthNoRedirect
      # * +client_identifier+: User agent for client app
      # * +locale+: The user's current locale (used to localize error messages)
      # * +host_info+: Website host addresses for testing. Defaults to the
      #   actual dropbox servers.
      def initialize(oauth2_access_token, client_identifier = '',locale = nil,
                     host_info = nil)
        unless oauth2_access_token.is_a?(String)
          fail ArgumentError, "oauth2_access_token must be a String; got "\
                  "#{ oauth2_access_token.inspect }"
        end
        host_info ||= Dropbox::API::HostInfo.default
        session = Dropbox::API::Session.new(oauth2_access_token,
                                     client_identifier, locale, host_info)
        {% for namespace_name in api.namespaces.keys() %}
        @{{ namespace_name|variable }} = {{ namespace_name|class }}.new(session)
        {% endfor %}
      end

      private

      # This class divides API endpoints into separate namespaces. Each
      # namespace's endpoints are stored in a different subclass. The outer
      # Client class stores a reference to one of each subclass.
      #
      # Usage example:
      #   client = Client.new(...)
      #   client.files.info('/file/path')
      #   client.users.info('me')
      class EndpointNamespace
        def initialize(session)
          @session = session
        end
      end

      {% for namespace_name, namespace in api.namespaces.items() %}
      {{ namespace_def(namespace_name, namespace, 6) }}
      {% endfor %}
    end
  end
end