# Generated by BabelSDK

# DO NOT EDIT THIS FILE.
# This file is auto-generated from the babel template client.babelt.rb.
# Any changes here will silently disappear.

module Dropbox
  module API

    # Use this class to make Dropbox API calls.  You'll need to obtain an
    # OAuth 2 access token first; you can get one using either WebAuth or
    # WebAuthNoRedirect.
    class Client

      attr_accessor :files, :users

      # Args:
      # * +oauth2_access_token+: Obtained via WebAuth or WebAuthNoRedirect
      # * +client_identifier+: User agent for client app
      # * +locale+: The user's current locale (used to localize error messages)
      # * +host_info+: Website host addresses for testing. Defaults to the
      #   actual dropbox servers.
      def initialize(oauth2_access_token, client_identifier = '',locale = nil,
                     host_info = nil)
        unless oauth2_access_token.is_a?(String)
          fail ArgumentError, "oauth2_access_token must be a String; got "\
                  "#{ oauth2_access_token.inspect }"
        end
        host_info ||= Dropbox::API::HostInfo.default
        session = Dropbox::API::Session.new(oauth2_access_token,
                                     client_identifier, locale, host_info)
        @files = Files.new(session)
        @users = Users.new(session)
      end

      private

      # This class divides API endpoints into separate namespaces. Each
      # namespace's endpoints are stored in a different subclass. The outer
      # Client class stores a reference to one of each subclass.
      #
      # Usage example:
      #   client = Client.new(...)
      #   client.files.info('/file/path')
      #   client.users.info('me')
      class EndpointNamespace
        def initialize(session)
          @session = session
        end
      end

      class Files < EndpointNamespace
        def initialize(session)
          super(session)
          @namespace = 'files'
        end
      
        # Get the contents of a folder.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the folder.
        # * +include_deleted+ (+boolean+): 
        #   If this parameter is set to true, then contents will include the
        #   metadata of deleted children. Note that the target of the
        #   Dropbox::API::Client::Files.folder_list` call is always returned even
        #   when it has been deleted (with is_deleted set to true) regardless of
        #   this flag.
        # * +include_media_info+ (+boolean+): 
        #   If true, each file will include a media_info key.
        #
        # Returns:
        #   FolderInfoAndContents
        def folder_list(path, include_deleted, include_media_info)
          input_json = {
            path: path,
            include_deleted: include_deleted,
            include_media_info: include_media_info,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/folder-list", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::FolderInfoAndContents.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Get the info for a file or folder.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +path_rev+ (+String+): 
        #   Specific revision for a given path.
        #
        # Returns:
        #   FileOrFolderInfo
        def info(path, opts = {})
          optional_inputs = {
          }.merge(opts)
          input_json = {
            path: path,
            path_rev: optional_inputs[:path_rev],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/info", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::FileOrFolderInfo.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Download a file.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +path_rev+ (+String+): 
        #   Specific revision for a given path.
        #
        # Returns:
        #   FileInfo
        def download(path, opts = {})
          optional_inputs = {
          }.merge(opts)
          input_json = {
            path: path,
            path_rev: optional_inputs[:path_rev],
          }
          response = @session.do_content_endpoint("/#{ @namespace }/download", input_json)
          file, metadata = Dropbox::API::HTTP.parse_content_response(response)
          return file, Dropbox::API::FileInfo.from_json(metadata)
        end
        
        # Upload a file to Dropbox.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The full path to the file you want to write to. It should not point to
        #   a folder.
        # * +write_conflict_policy+ (+WriteConflictPolicy+): 
        #   Action to take if a file already exists at the specified path.
        # * +in2+
        #   File-like object
        #
        # Returns:
        #   FileInfo
        def upload(path, write_conflict_policy, in2)
          input_json = {
            path: path,
            write_conflict_policy: write_conflict_policy,
          }
          response = @session.do_content_endpoint("/#{ @namespace }/upload", input_json, in2)
          file, metadata = Dropbox::API::HTTP.parse_content_response(response)
          return file, Dropbox::API::FileInfo.from_json(metadata)
        end
        
        # A way of letting you keep up with changes to files and folders in a
        # user's Dropbox. You can periodically call
        # Dropbox::API::Client::Files.delta` to get a list of "delta entries",
        # which are instructions on how to update your local state to match the
        # server's state.
        #
        # Required args:
        # * +cursor+ (+String+): 
        #   A string that is used to keep track of your current state. On the next
        #   call pass in this value to return delta entries that have been
        #   recorded since the cursor was returned.
        # * +path_prefix+ (+String+): 
        #   Filters the response to only include entries at or under the specified
        #   path. If you use the path_prefix parameter, you must continue to pass
        #   the same prefix on subsequent calls using the returned cursor.
        # * +include_media_info+ (+boolean+): (defaults to false)
        #   If , each file will include a media_info key. When include_media_info
        #   is specified, files will only appear in delta responses when the media
        #   info is ready. If you use the include_media_info parameter, you must
        #   continue to pass the same value on subsequent calls using the returned
        #   cursor.
        #
        # Returns:
        #   DeltaResponse
        def delta(cursor, path_prefix, include_media_info = false)
          input_json = {
            cursor: cursor,
            path_prefix: path_prefix,
            include_media_info: include_media_info,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/delta", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::DeltaResponse.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # A long-poll endpoint to wait for changes on an account. In conjunction
        # with Dropbox::API::Client::Files.delta`, this call gives you a low-
        # latency way to monitor an account for file changes.
        # Unlike most other
        # API endpoints, this call does not require OAuth authentication. The
        # passed in cursor can only be acquired via an authenticated call to
        # Dropbox::API::Client::Files.delta`.
        #
        # Required args:
        # * +cursor+ (+String+): 
        #   A delta cursor as returned from a call to
        #   Dropbox::API::Client::Files.delta`. Note that a cursor returned from a
        #   call to Dropbox::API::Client::Files.delta` with include_media_info set
        #   to  is incompatible with Dropbox::API::Client::Files.longpoll_delta`
        #   and an error will be returned.
        #
        # Optional args:
        # * +timeout+ (+Integer+): (defaults to 30)
        #   An optional integer indicating a timeout, in seconds. The request will
        #   block for at most this length of time, plus up to 90 seconds of random
        #   jitter added to avoid the thundering herd problem
        #   https://en.wikipedia.org/wiki/Thundering_herd_problem. Care should be
        #   taken when using this parameter, as some network infrastructure does
        #   not support long timeouts.
        #
        # Returns:
        #   LongpollDeltaResponse
        def longpoll_delta(cursor, opts = {})
          optional_inputs = {
            timeout: 30,
          }.merge(opts)
          input_json = {
            cursor: cursor,
            timeout: optional_inputs[:timeout],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/longpolldelta", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::LongpollDeltaResponse.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Get the thumbnail for a file.
        #
        # Required args:
        # * +format+ (+String+): 
        #   jpeg (default) or png. For images that are photos, jpeg should be
        #   preferred, while png is better for screenshots and digital art.
        #
        # Optional args:
        # * +size+ (+String+): (defaults to 's')
        #   One of the following values: xs, s, m, l, xl.
        #
        # Returns:
        #   FileInfo
        def thumbnail(format, opts = {})
          optional_inputs = {
            size: 's',
          }.merge(opts)
          input_json = {
            format: format,
            size: optional_inputs[:size],
          }
          response = @session.do_content_endpoint("/#{ @namespace }/thumbnail", input_json)
          file, metadata = Dropbox::API::HTTP.parse_content_response(response)
          return file, Dropbox::API::FileInfo.from_json(metadata)
        end
        
        # Obtains file information for previous revisions.
        # Only revisions up to
        # thirty days old are available (or more if the Dropbox user has Packrat
        # https://www.dropbox.com/help/113). You can use the revision number in
        # conjunction with the Dropbox::API::Client::Files.restore` call to
        # revert the file to its previous state.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +path_rev+ (+String+): 
        #   Specific revision for a given path.
        #
        # Returns:
        #   RevisionHistory
        def revisions(path, opts = {})
          optional_inputs = {
          }.merge(opts)
          input_json = {
            path: path,
            path_rev: optional_inputs[:path_rev],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/revisions", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::RevisionHistory.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Restores a file path to a previous revision.
        # Unlike downloading a file
        # at a given revision and then re-uploading it, this call is atomic. It
        # also saves a bunch of bandwidth.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        # * +rev+ (+String+): 
        #   The revision of a path to restore to.
        #
        # Returns:
        #   FileInfo
        def restore(path, rev)
          input_json = {
            path: path,
            rev: rev,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/restore", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::FileInfo.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Returns metadata for all files and folders whose filename contains the
        # given search string as a substring.
        # Searches are limited to the folder
        # path and its sub-folder hierarchy provided in the call.
        #
        # Required args:
        # * +query+ (+String+): 
        #   The search string. This string is split (on spaces) into individual
        #   words. Files and folders will be returned if they contain all words in
        #   the search string.
        # * +file_limit+ (+Integer+): (defaults to 1000)
        #   The maximum and default value is 1,000. No more than file_limit search
        #   results will be returned.
        #
        # Optional args:
        # * +include_deleted+ (+boolean+): (defaults to false)
        #   If this parameter is set to true, then files and folders that have
        #   been deleted will also be included in the search.
        # * +include_membership+ (+boolean+): (defaults to false)
        #   If true, metadata for a shared folder will include a list of the
        #   members of the shared folder.
        #
        # Returns:
        #   SearchResults
        def search(query, file_limit = 1000, opts = {})
          optional_inputs = {
            include_deleted: false,
            include_membership: false,
          }.merge(opts)
          input_json = {
            query: query,
            file_limit: file_limit,
            include_deleted: optional_inputs[:include_deleted],
            include_membership: optional_inputs[:include_membership],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/search", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::SearchResults.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Gets a preview for a file.
        # The Content-Type header will be either
        # application/pdf or text/html. There is an Original-Content-Length
        # header which contains the size of the preview data.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +path_rev+ (+String+): 
        #   Specific revision for a given path.
        #
        # Returns:
        #   FileInfo
        def preview(path, opts = {})
          optional_inputs = {
          }.merge(opts)
          input_json = {
            path: path,
            path_rev: optional_inputs[:path_rev],
          }
          response = @session.do_content_endpoint("/#{ @namespace }/preview", input_json)
          file, metadata = Dropbox::API::HTTP.parse_content_response(response)
          return file, Dropbox::API::FileInfo.from_json(metadata)
        end
        
        # Copies a file or folder to a new location.
        #
        # Required args:
        # * +from_path+ (+String+): 
        #   Specifies the file or folder to be copied.
        # * +to_path+ (+String+): 
        #   Specifies the destination path, including the new name for the file or
        #   folder.
        #
        # Returns:
        #   FileInfo
        def copy(from_path, to_path)
          input_json = {
            from_path: from_path,
            to_path: to_path,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/copy", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::FileInfo.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Moves a file or folder to a new location.
        #
        # Required args:
        # * +from_path+ (+String+): 
        #   Specifies the file or folder to be copied.
        # * +to_path+ (+String+): 
        #   Specifies the destination path, including the new name for the file or
        #   folder.
        #
        # Returns:
        #   FileInfo
        def move(from_path, to_path)
          input_json = {
            from_path: from_path,
            to_path: to_path,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/move", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::FileInfo.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Creates a folder.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the new folder to create.
        #
        # Returns:
        #   FileInfo
        def folder_create(path)
          input_json = {
            path: path,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/folder-create", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::FileInfo.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Deletes a file or folder.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder to be deleted.
        #
        # Returns:
        #   FileInfo
        def delete(path)
          input_json = {
            path: path,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/delete", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::FileInfo.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
      end
      
      class Users < EndpointNamespace
        def initialize(session)
          super(session)
          @namespace = 'users'
        end
      
        # Get user account information.
        #
        # Required args:
        # * +account_id+ (+String+): 
        #   A user's account identifier. Use "me" to get information for the
        #   current account.
        #
        # Returns:
        #   AccountInfo
        def info(account_id)
          input_json = {
            account_id: account_id,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/info", input_json)
          # If this is a multi-part response, this won't work yet.
          Dropbox::API::AccountInfo.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
      end
      
    end
  end
end