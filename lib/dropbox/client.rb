# Generated by BabelSDK

module Dropbox
  module API

    # Use this class to make Dropbox API calls.  You'll need to obtain an
    # OAuth 2 access token first; you can get one using either WebAuth or
    # WebAuthNoRedirect.
    class Client

      # Args:
      # * +oauth2_access_token+: Obtained via WebAuth or WebAuthNoRedirect
      # * +client_identifier+: User agent for client app
      # * +root+: root that paths are specified from. Valid values are 'auto'
      #   (default/recommended), 'dropbox', and 'sandbox'
      # * +locale+: The user's current locale (used to localize error messages)
      # * +host_info+: Website host addresses for testing. Defaults to the
      #   actual dropbox servers.
      def initialize(oauth2_access_token, client_identifier = '',
                     root = 'auto', locale = nil, host_info = nil)
        unless oauth2_access_token.is_a?(String)
          fail ArgumentError, "oauth2_access_token must be a String; got "\
                  "#{ oauth2_access_token.inspect }"
        end
        host_info ||= Dropbox::API::HostInfo.default
        @session = Dropbox::API::Session.new(oauth2_access_token,
                                     client_identifier, locale, host_info)
        @root = root.to_s  # If they passed in a symbol, make it a string

        unless ['dropbox', 'app_folder', 'auto'].include?(@root)
          fail ArgumentError, 'root must be "dropbox", "app_folder", or "auto"'
        end

        # App Folder is the name of the access type, but for historical reasons
        # sandbox is the URL root component that indicates this
        if @root == 'app_folder'
          @root = 'sandbox'
        end
      end

      # Get the info for a file or folder.
      #
      # Args:
      # * +path+ (+String+):
      #   The path to the file or folder.
      #
      # Returns:
      #   FileOrFolderInfo
      def metadata(path = nil)
        input = {
        }
        response = @session.do_rpc_endpoint("/files/metadata", input)
        # If this is a multi-part response, this won't work yet.
        Dropbox::API::FileOrFolderInfo.from_json(Dropbox::API::HTTP.parse_response(response))
      end
      
      # Download a file.
      #
      # Args:
      # * +path+ (+String+):
      #   The path to the file or folder.
      #
      # Returns:
      #   FileInfo
      def download(path = nil)
        input = {
        }
        response = @session.do_content_endpoint("/files/download", input)
        file, metadata = Dropbox::API::HTTP.parse_response(response)
        return file, Dropbox::API::FileInfo.from_json(metadata)
      end
      
      # Request the contents of a folder.
      #
      # Args:
      # * +path+ (+String+):
      #   The path to the folder.
      # * +include_deleted+ (+Boolean+):
      #   Only applicable when list is set. If this parameter is set to true,
      #   then contents will include the metadata of deleted children. Note that
      #   the target of the metadata call is always returned even when it has
      #   been deleted (with is_deleted set to true) regardless of this flag.
      # * +include_media_info+ (+Boolean+):
      #   If true, each file will include a media_info key.
      #
      # Returns:
      #   FolderInfo
      def folder_list(path = nil, include_deleted = nil, include_media_info = nil)
        input = {
          include_deleted: include_deleted,
          include_media_info: include_media_info,
        }
        response = @session.do_rpc_endpoint("/files/folder-list", input)
        # If this is a multi-part response, this won't work yet.
        Dropbox::API::FolderInfo.from_json(Dropbox::API::HTTP.parse_response(response))
      end
      
      # A way of letting you keep up with changes to files and folders in a
      # user's Dropbox. You can periodically call /delta to get a list of
      # "delta entries", which are instructions on how to update your local
      # state to match the server's state.
      #
      # Args:
      # * +cursor+ (+String+):
      #   A string that is used to keep track of your current state. On the next
      #   call pass in this value to return delta entries that have been
      #   recorded since the cursor was returned.
      # * +path_prefix+ (+String+):
      #   Filters the response to only include entries at or under the specified
      #   path. If you use the path_prefix parameter, you must continue to pass
      #   the same prefix on subsequent calls using the returned cursor.
      # * +include_media_info+ (+Boolean+):
      #   If true, each file will include a media_info key. When
      #   include_media_info is specified, files will only appear in delta
      #   responses when the media info is ready. If you use the
      #   include_media_info parameter, you must continue to pass the same value
      #   on subsequent calls using the returned cursor.
      #
      # Returns:
      #   DeltaHeader
      def delta(cursor = nil, path_prefix = nil, include_media_info = nil)
        input = {
          cursor: cursor,
          path_prefix: path_prefix,
          include_media_info: include_media_info,
        }
        response = @session.do_rpc_endpoint("/files/delta", input)
        # If this is a multi-part response, this won't work yet.
        Dropbox::API::DeltaHeader.from_json(Dropbox::API::HTTP.parse_response(response))
      end
      
      # Get the thumbnail for a file.
      #
      # Args:
      # * +format+ (+String+):
      #   jpeg (default) or png. For images that are photos, jpeg should be
      #   preferred, while png is better for screenshots and digital art.
      # * +size+ (+String+):
      #   One of the following values: xs, s (default), m, l, xl.
      #
      # Returns:
      #   FileInfo
      def thumbnail(format = nil, size = nil)
        input = {
          format: format,
          size: size,
        }
        response = @session.do_content_endpoint("/files/thumbnail", input)
        file, metadata = Dropbox::API::HTTP.parse_response(response)
        return file, Dropbox::API::FileInfo.from_json(metadata)
      end
      
      # Obtains metadata for the previous revisions of a file.
      # Only revisions
      # up to thirty days old are available (or more if the Dropbox user has
      # Packrat). You can use the revision number in conjunction with the
      # /restore call to revert the file to its previous state.
      #
      # Args:
      # * +path+ (+String+):
      #   The path to the file or folder.
      #
      # Returns:
      #   EntryInfo
      def revisions(path = nil)
        input = {
        }
        response = @session.do_rpc_endpoint("/files/revisions", input)
        # If this is a multi-part response, this won't work yet.
        Dropbox::API::EntryInfo.from_json(Dropbox::API::HTTP.parse_response(response))
      end
      
      # Upload a file to Dropbox.
      #
      # Args:
      # * +path+ (+String+):
      #   The full path to the file you want to write to. It should not point to
      #   a folder.
      # * +write_conflict_policy+ (+WriteConflictPolicy+):
      #   Action to take if a file already exists at the specified path.
      #
      # Returns:
      #   FileInfo
      def upload(path = nil, write_conflict_policy = nil, in2 = nil)
        input = {
          write_conflict_policy: write_conflict_policy,
        }
        response = @session.do_content_endpoint("/files/upload", input, in2)
        # If this is a multi-part response, this won't work yet.
        Dropbox::API::FileInfo.from_json(Dropbox::API::HTTP.parse_response(response))
      end
      
      # Get user account information.
      #
      # Args:
      # * +account_id+ (+String+):
      #   A user's account identifier. Use "me" to get information for the
      #   current account.
      #
      # Returns:
      #   AccountInfo
      def info(account_id = nil)
        input = {
          account_id: account_id,
        }
        response = @session.do_rpc_endpoint("/users/info", input)
        # If this is a multi-part response, this won't work yet.
        Dropbox::API::AccountInfo.from_json(Dropbox::API::HTTP.parse_response(response))
      end
      

      private

      # From the oauth spec plus "/".  Slash should not be ecsaped
      RESERVED_CHARACTERS = /[^a-zA-Z0-9\-\.\_\~\/]/  # :nodoc:

      def format_path(path, escape = true) # :nodoc:
        # replace multiple slashes with a single one
        path.gsub!(/\/+/, '/')

        # ensure the path starts with a slash
        path.gsub!(/^\/?/, '/')

        # ensure the path doesn't end with a slash
        path.gsub!(/\/?$/, '')

        escape ? URI.escape(path, RESERVED_CHARACTERS) : path
      end

      # Parses out file metadata from a raw dropbox HTTP response.
      #
      # Args:
      # * +response+: The raw, unparsed HTTPResponse from Dropbox.
      #
      # Returns:
      # * The metadata of the file as a hash.
      def parse_metadata(response) # :nodoc:
        begin
          raw_metadata = response['x-dropbox-metadata']
          metadata = JSON.parse(raw_metadata)
        rescue
          raise DropboxError.new("Dropbox Server Error: x-dropbox-metadata=#{raw_metadata}",
                       response)
        end
        return metadata
      end

    end
  end
end