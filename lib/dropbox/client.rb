# Generated by BabelSDK

# This file is auto-generated from the babel template client.babelt.rb.
# Any changes here will silently disappear. And no, this isn't a
# reference to http://stackoverflow.com/a/740603/3862658. Changes will
# actually disappear.

module Dropbox
  module API

    # Use this class to make Dropbox API calls.  You'll need to obtain an
    # OAuth2 access token first; you can get one using either WebAuth or
    # WebAuthNoRedirect.
    #
    # Methods for API calls are split into namespaces. The Client class
    # stores a reference to each namespace. For example, for file and
    # folder operations:
    #
    #   client = Dropbox::API::Client.new(...)
    #   client.files.info(...) # => Entry object
    class Client

      attr_accessor :files, :users, :oauth2,
          :client_identifier, :access_token, :locale, :host_info

      # Args:
      # * +oauth2_access_token+: Obtained via WebAuth or WebAuthNoRedirect
      # * +client_identifier+: User agent for client app
      # * +locale+: The user's current locale (used to localize error messages)
      # * +host_info+: Website host addresses for testing. Defaults to the
      #   actual dropbox servers.
      def initialize(oauth2_access_token, client_identifier = '', locale = nil,
                     host_info = nil)
        host_info ||= Dropbox::API::HostInfo.default
        session = Dropbox::API::Session.new(oauth2_access_token,
                                     client_identifier, locale, host_info)
        @files = Files.new(session)
        @users = Users.new(session)
        @oauth2 = OAuth2.new(session)
        @client_identifier = client_identifier
        @access_token = oauth2_access_token
        @locale = locale
        @host_info = host_info
      end

      # Returns a ChunkedUploader object.
      #
      # Args:
      # * +file_obj+: The file-like object to be uploaded. Must support .read()
      # * +total_size+: The total size of file_obj
      def get_chunked_uploader(file_obj, total_size)
        ChunkedUploader.new(self, file_obj, total_size)
      end

      # ChunkedUploader is responsible for uploading a large file to Dropbox
      # in smaller chunks. This allows large files to be uploaded and allows
      # recovery during failure.
      class ChunkedUploader
        attr_accessor :file_obj, :total_size, :offset, :upload_id, :client

        def initialize(client, file_obj, total_size)
          @client = client
          @file_obj = file_obj
          @total_size = total_size
          @upload_id = nil
          @offset = 0
        end

        # Uploads data from this ChunkedUploader's file_obj in chunks, until
        # an error occurs. Throws an exception when an error occurs, and can
        # be called again to resume the upload.
        #
        # Args:
        # * +chunk_size+: The chunk size for each individual upload. Defaults
        #   to 4MB.
        def upload(chunk_size = 4*1024*1024)
          last_chunk = nil

          while @offset < @total_size
            if not last_chunk
              last_chunk = @file_obj.read(chunk_size)
            end

            body, result = @client.files.partial_chunked_upload(last_chunk,
                @upload_id, @offset)
            last_chunk = nil

            if result.offset > @offset
              @offset = result.offset
              last_chunk = nil
            end
            @upload_id = result.upload_id
          end
        end

        # Completes a chunked file upload. See the commit_chunked_upload
        # endpoint documentation.
        def finish(path, write_conflict_policy)
          @client.files.commit_chunked_upload(path, @upload_id, write_conflict_policy)
        end
      end

      private

      # This class divides API endpoints into separate namespaces. Each
      # namespace's endpoints are stored in a different subclass. The outer
      # Client class stores a reference to one of each subclass.
      #
      # Usage example:
      #   client = Client.new(...)
      #   client.files.info('/file/path')
      #   client.users.info('me')
      class EndpointNamespace
        def initialize(session)
          @session = session
        end
      end

      # Endpoints for other oauth methods that aren't covered in the OAuth2
      # module for the authorization flow. The token_from_oauth1 endpoint is
      # not included here because the Dropbox::API::Client object in this SDK
      # only supports OAuth2.
      class OAuth2 < EndpointNamespace
        def initialize(session)
          super(session)
          @namespace = 'oauth2'
        end

        # Disables the access token used by this client.
        def revoke
          @session.do_rpc_endpoint('/revoke')
          nil
        end
      end

      class Files < EndpointNamespace
        def initialize(session)
          super(session)
          @namespace = 'files'
        end
      
        # Get the contents of a folder.
        # Either a +path+ or +id+ must be
        # specified.
        #
        # Required args:
        #
        # Optional args:
        # * +id+ (+String+): 
        #   The path to the folder.
        # * +path+ (+String+): 
        #   The id of the folder.
        # * +include_deleted+ (+boolean+): (defaults to +false+)
        #   If this parameter is set to true, then +contents+ will include the
        #   metadata of deleted children. Note that the target of the
        #   Dropbox::API::Client::Files.folder_list call is always returned even
        #   when it has been deleted (with +is_deleted+ set to true) regardless of
        #   this flag.
        # * +include_media_info+ (+boolean+): (defaults to +false+)
        #   If true, each file will include a media_info key.
        #
        # Returns: FolderAndContents
        def folder_list(opts = {})
          optional_inputs = {
            include_deleted: false,
            include_media_info: false,
          }.merge(opts)
          input_json = {
            id: optional_inputs[:id],
            path: optional_inputs[:path],
            include_deleted: optional_inputs[:include_deleted],
            include_media_info: optional_inputs[:include_media_info],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/folder_list", input_json)
          Dropbox::API::FolderAndContents.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Get the info for a file or folder.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +path_revision+ (+String+): 
        #   Specific revision for a given path.
        #
        # Returns: Entry
        def info(path, opts = {})
          optional_inputs = opts
          input_json = {
            path: path,
            path_revision: optional_inputs[:path_revision],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/info", input_json)
          Dropbox::API::Entry.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Download a file.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +path_revision+ (+String+): 
        #   Specific revision for a given path.
        #
        # Returns: File contents (String), File
        def download(path, opts = {})
          optional_inputs = opts
          input_json = {
            path: path,
            path_revision: optional_inputs[:path_revision],
          }
          response = @session.do_content_endpoint("/#{ @namespace }/download", input_json)
          file, metadata = Dropbox::API::HTTP.parse_content_response(response)
          return file, Dropbox::API::File.from_json(metadata)
        end
        
        # Upload a file to Dropbox.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The full path to the file you want to write to. It should not point to
        #   a folder.
        # * +write_conflict_policy+ (+WriteConflictPolicy+): 
        #   Action to take if a file already exists at the specified path.
        # * +in2+
        #   File-like object
        #
        # Returns: File
        def upload(path, write_conflict_policy, in2, opts = {})
          input_json = {
            path: path,
            write_conflict_policy: write_conflict_policy,
          }
          response = @session.do_content_endpoint("/#{ @namespace }/upload", input_json, in2)
          file, metadata = Dropbox::API::HTTP.parse_content_response(response)
          return Dropbox::API::File.from_json(metadata)
        end
        
        # Gets a preview for a file.
        # The Content-Type header will be either
        # application/pdf or text/html. There is an Original-Content-Length
        # header which contains the size of the preview data.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +path_revision+ (+String+): 
        #   Specific revision for a given path.
        #
        # Returns: File contents (String), File
        def preview(path, opts = {})
          optional_inputs = opts
          input_json = {
            path: path,
            path_revision: optional_inputs[:path_revision],
          }
          response = @session.do_content_endpoint("/#{ @namespace }/preview", input_json)
          file, metadata = Dropbox::API::HTTP.parse_content_response(response)
          return file, Dropbox::API::File.from_json(metadata)
        end
        
        # Get the thumbnail for a file.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +format+ (+String+): (defaults to +'jpeg'+)
        #   jpeg (default) or png. For images that are photos, jpeg should be
        #   preferred, while png is better for screenshots and digital art.
        # * +size+ (+String+): (defaults to +'s'+)
        #   One of the following values: xs, s, m, l, xl.
        #
        # Returns: File contents (String), File
        def thumbnail(path, opts = {})
          optional_inputs = {
            format: 'jpeg',
            size: 's',
          }.merge(opts)
          input_json = {
            path: path,
            format: optional_inputs[:format],
            size: optional_inputs[:size],
          }
          response = @session.do_content_endpoint("/#{ @namespace }/thumbnail", input_json)
          file, metadata = Dropbox::API::HTTP.parse_content_response(response)
          return file, Dropbox::API::File.from_json(metadata)
        end
        
        # A way of letting you keep up with changes to files and folders in a
        # user's Dropbox. You can periodically call
        # Dropbox::API::Client::Files.delta to get a list of "delta entries",
        # which are instructions on how to update your local state to match the
        # server's state.
        #
        # Required args:
        # * +cursor+ (+String+): 
        #   A string that is used to keep track of your current state. On the next
        #   call pass in this value to return delta entries that have been
        #   recorded since the cursor was returned.
        #
        # Optional args:
        # * +path_prefix+ (+String+): 
        #   Filters the response to only include entries at or under the specified
        #   path.
        # * +include_media_info+ (+boolean+): (defaults to +false+)
        #   If true, each file will include a +media_info+ key. When
        #   +include_media_info+ is specified, files will only appear in delta
        #   responses when the media info is ready.
        # * +include_membership+ (+boolean+): (defaults to +false+)
        #   If true, each shared folder will include a list of the members of the
        #   shared folder.
        #
        # Returns: DeltaResponse
        def delta(cursor, opts = {})
          optional_inputs = {
            include_media_info: false,
            include_membership: false,
          }.merge(opts)
          input_json = {
            cursor: cursor,
            path_prefix: optional_inputs[:path_prefix],
            include_media_info: optional_inputs[:include_media_info],
            include_membership: optional_inputs[:include_membership],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/delta", input_json)
          Dropbox::API::DeltaResponse.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # A long-poll endpoint to wait for changes on an account. In conjunction
        # with Dropbox::API::Client::Files.delta, this call gives you a low-
        # latency way to monitor an account for file changes.
        # Unlike most other
        # API endpoints, this call does not require OAuth authentication. The
        # passed in +cursor+ can only be acquired via an authenticated call to
        # Dropbox::API::Client::Files.delta.
        #
        # Required args:
        # * +cursor+ (+String+): 
        #   A delta cursor as returned from a call to
        #   Dropbox::API::Client::Files.delta. Note that a cursor returned from a
        #   call to Dropbox::API::Client::Files.delta with +include_media_info+
        #   set to true is incompatible with
        #   Dropbox::API::Client::Files.longpoll_delta and an error will be
        #   returned.
        #
        # Optional args:
        # * +timeout+ (+Integer+): (defaults to +30+)
        #   An optional integer indicating a timeout, in seconds. The request will
        #   block for at most this length of time, plus up to 90 seconds of random
        #   jitter added to avoid the thundering herd problem
        #   https://en.wikipedia.org/wiki/Thundering_herd_problem. Care should be
        #   taken when using this parameter, as some network infrastructure does
        #   not support long timeouts.
        #
        # Returns: LongpollDeltaResponse
        def longpoll_delta(cursor, opts = {})
          optional_inputs = {
            timeout: 30,
          }.merge(opts)
          input_json = {
            cursor: cursor,
            timeout: optional_inputs[:timeout],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/longpoll_delta", input_json)
          Dropbox::API::LongpollDeltaResponse.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Obtains file information for previous revisions.
        # Only revisions up to
        # thirty days old are available (or more if the Dropbox user has Packrat
        # https://www.dropbox.com/help/113). You can use the revision number in
        # conjunction with the Dropbox::API::Client::Files.restore call to
        # revert the file to its previous state.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        #
        # Optional args:
        # * +path_revision+ (+String+): 
        #   Specific revision for a given path.
        #
        # Returns: RevisionHistory
        def revisions(path, opts = {})
          optional_inputs = opts
          input_json = {
            path: path,
            path_revision: optional_inputs[:path_revision],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/revisions", input_json)
          Dropbox::API::RevisionHistory.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Restores a file path to a previous revision.
        # Unlike downloading a file
        # at a given revision and then re-uploading it, this call is atomic. It
        # also saves a bunch of bandwidth.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder.
        # * +rev+ (+String+): 
        #   The revision of a path to restore to.
        #
        # Returns: File
        def restore(path, rev, opts = {})
          input_json = {
            path: path,
            rev: rev,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/restore", input_json)
          Dropbox::API::File.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Returns metadata for all files and folders whose filename contains the
        # given search string as a substring.
        # Searches are limited to the folder
        # path and its sub-folder hierarchy provided in the call.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The folder prefix to search.
        # * +query+ (+String+): 
        #   The search string. This string is split (on spaces) into individual
        #   words. Files and folders will be returned if they contain all words in
        #   the search string.
        #
        # Optional args:
        # * +file_limit+ (+Integer+): (defaults to +1000+)
        #   The maximum and default value is 1,000. No more than file_limit search
        #   results will be returned.
        # * +include_deleted+ (+boolean+): (defaults to +false+)
        #   If this parameter is set to true, then files and folders that have
        #   been deleted will also be included in the search.
        # * +include_membership+ (+boolean+): (defaults to +false+)
        #   If true, metadata for a shared folder will include a list of the
        #   members of the shared folder.
        #
        # Returns: SearchResults
        def search(path, query, opts = {})
          optional_inputs = {
            file_limit: 1000,
            include_deleted: false,
            include_membership: false,
          }.merge(opts)
          input_json = {
            path: path,
            query: query,
            file_limit: optional_inputs[:file_limit],
            include_deleted: optional_inputs[:include_deleted],
            include_membership: optional_inputs[:include_membership],
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/search", input_json)
          Dropbox::API::SearchResults.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Copies a file or folder to a new location.
        #
        # Required args:
        # * +from_path+ (+String+): 
        #   Specifies the file or folder to be copied.
        # * +to_path+ (+String+): 
        #   Specifies the destination path, including the new name for the file or
        #   folder.
        #
        # Returns: File
        def copy(from_path, to_path, opts = {})
          input_json = {
            from_path: from_path,
            to_path: to_path,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/copy", input_json)
          Dropbox::API::File.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Moves a file or folder to a new location.
        #
        # Required args:
        # * +from_path+ (+String+): 
        #   Specifies the file or folder to be copied.
        # * +to_path+ (+String+): 
        #   Specifies the destination path, including the new name for the file or
        #   folder.
        #
        # Returns: File
        def move(from_path, to_path, opts = {})
          input_json = {
            from_path: from_path,
            to_path: to_path,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/move", input_json)
          Dropbox::API::File.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Creates a folder.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the new folder to create.
        #
        # Returns: File
        def folder_create(path, opts = {})
          input_json = {
            path: path,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/folder_create", input_json)
          Dropbox::API::File.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Deletes a file or folder.
        #
        # Required args:
        # * +path+ (+String+): 
        #   The path to the file or folder to be deleted.
        #
        # Returns: File
        def delete(path, opts = {})
          input_json = {
            path: path,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/delete", input_json)
          Dropbox::API::File.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
        # Retrieves a file's descendants by ID. There are some operations that
        # can cause a file's ID to change. If this happens, Dropbox handles this
        # by creating a tree structure where the new ID is created as a child of
        # the file's original ID. You can track changes to a file's ID using
        # this endpoint. In the case that there is ambiguity to which file is
        # the correct descendant, all possible candidates are returned.
        # Returns
        # metadata for each descendant in a list. Any descendant that you do not
        # have permission to read is excluded.
        #
        # Required args:
        # * +id+ (+String+): 
        #   The ID whose children are returned.
        #
        # Returns: DescendantList
        def get_descendants(id, opts = {})
          input_json = {
            id: id,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/get_descendants", input_json)
          Dropbox::API::DescendantList.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
      end
      
      class Users < EndpointNamespace
        def initialize(session)
          super(session)
          @namespace = 'users'
        end
      
        # Get information about a user's account.
        #
        # Required args:
        # * +account_id+ (+String+): 
        #   A user's account identifier. Use "me" to get information for the
        #   current account.
        #
        # Returns: AccountInfo
        def info(account_id, opts = {})
          input_json = {
            account_id: account_id,
          }
          response = @session.do_rpc_endpoint("/#{ @namespace }/info", input_json)
          Dropbox::API::AccountInfo.from_json(Dropbox::API::HTTP.parse_rpc_response(response))
        end
        
      end
      
    end
  end
end