# babelsdk(jinja2)

# DO NOT EDIT THIS FILE.
# This file is auto-generated from the babel template objects.babelt.rb.
# Any changes here will silently disappear.

require 'date'

{%- macro struct_doc_ref(s) -%}
Dropbox::API::{{ s|class }}
{%- endmacro -%}

{%- macro op_doc_ref(s) -%}
Dropbox::API::Client::Files.{{ s|method }}`
{%- endmacro -%}

{%- macro field_doc_ref(s) -%}
{{ s }}
{%- endmacro -%}

{%- macro link_doc_ref(s) -%}
{{ s }}
{%- endmacro -%}

{%- macro val_doc_ref(s) -%}
{%- if s == 'True' -%}
+true+
{%- elif s == 'False' -%}
+false+
{%- elif s == 'null' -%}
+nil+
{%- endif -%}
{%- endmacro -%}

{%- macro ruby_doc_sub(s) -%}
{{ s|doc_sub(struct=struct_doc_ref, op=op_doc_ref, field=field_doc_ref, link=link_doc_ref, val=val_doc_ref) }}
{%- endmacro -%}

{%- macro typename(field) -%}
{%- if field.data_type -%}
{%- if field.data_type.composite_type -%}
{{ ' ' }}(+{{ field.data_type.name|class }}+)
{%- else -%}
{{ ' ' }}(+{{ field.data_type|type }}+)
{%- endif -%}
{%- endif -%}
{%- endmacro -%}

{%- macro arg_doc(fields) -%}
{% for field in fields %}
# * +{{ field.name }}+{{ typename(field) }}{{ ' ' }}
{%- if field.has_default %}(defaults to {{ field.default|pprint }})
{% else %}{# blank block for a newline here #}

{% endif %}
{% if field.doc %}
#   {{ ruby_doc_sub(field.doc)|wordwrap(70)|replace('\n', '\n#   ') }}
{% endif %}
{% endfor %}
{%- endmacro -%}

{%- macro struct_docs(data_type) -%}
{% if data_type.doc %}
# {{ ruby_doc_sub(data_type.doc)|wordwrap(70)|replace('\n', '\n# ') }}
#
{% endif %}
# Required fields:
{{ arg_doc(data_type.all_required_fields) -}}
{% if data_type.all_optional_fields|length > 0 %}
#
# Optional fields:
{{ arg_doc(data_type.all_optional_fields) -}}
{% endif %}
{%- endmacro -%}

{%- macro union_docs(data_type) -%}
{% if data_type.doc %}
# {{ ruby_doc_sub(data_type.doc)|wordwrap(70)|replace('\n', '\n# ') }}
#
{% endif %}
# Member types:
{{ arg_doc(data_type.all_fields) -}}
{%- endmacro -%}

{%- macro arg_list(args) -%}
{% for arg in args %}
{{ arg.name }}{% if arg.has_default %} = {{ arg.default|pprint }}{% elif arg.optional %} = nil{% endif %},
{% endfor %}
{%- endmacro -%}

{%- macro object_def(data_type, indent_spaces) -%}
{%- filter indent(indent_spaces, indentfirst=True) -%}
{%- if data_type.composite_type == 'struct' and not data_type.name.endswith('Request') -%}
{{ struct_docs(data_type) -}}
class {{ data_type.name|class }}{% if data_type.super_type %} < {{ data_type.super_type.name|class }}{% endif %}

  {% if data_type.fields %}
  attr_accessor(
      {{ data_type.fields|map(attribute='name')|map('inverse_format', ':{0}')|join(',\n      ') }}
  )
  {% endif %}

  def initialize(
      {{ arg_list(data_type.all_fields)|indent(6)|string_slice(0, -1) }}
  )
  {% for field in data_type.all_fields %}
    @{{ field.name }} = {{ field.name }}
  {% endfor %}
  end

  # Initializes an instance of {{ data_type.name|class }} from
  # JSON-formatted data.
  def self.from_json(json)
    self.new(
      {% for field in data_type.all_fields %}
        {%+ if field.nullable -%}
        json['{{ field.name }}'].nil? ? nil :{{ ' ' }}
        {%- elif field.optional -%}
        !json.include?('{{ field.name }}') ? nil :{{ ' ' }}
        {%- endif %}
        {% if field.data_type.composite_type -%}
        {{ field.data_type.name|class }}.from_json(json['{{ field.name }}']),
        {% elif field.data_type.name == 'Timestamp' -%}
        Dropbox::API::convert_date(json['{{ field.name }}']),
        {% elif field.data_type.name == 'List' and field.data_type.data_type.composite_type -%}
        json['{{ field.name }}'].collect { |elem| {{ field.data_type.data_type.name|class }}.from_json(elem) },
        {% else -%}
        json['{{ field.name }}'],
        {% endif %}
      {% endfor %}
    )
  end
end

{% elif data_type.composite_type == 'union' and not data_type.name.endswith('Error') -%}
# This class is a tagged union. For more information on tagged unions,
# see the README.
#
{{ union_docs(data_type) -}}
class {{ data_type.name|class }}

  # Allowed tags for this union
  TAGS = [{{ data_type.all_fields|map(attribute='name')|map('inverse_format', ':{0}')|join(', ') }}]

  def initialize(tag, val = nil)
    if !TAGS.include?(tag)
        fail ArgumentError, "Invalid symbol '#{ tag }' for this union."\
            " #{ TAGS }"
    end
    @tag = tag
    @val = val
  end

  # If the union's type is a symbol field, returns the symbol. If the type
  # is a struct, returns the struct. You can also use each individual
  # attribute accessor to retrieve the value for non-symbol union types.
  def value
    @val.nil? ? @tag : @val
  end

  # Returns this object as a hash for JSON conversion.
  def as_json(options = {})
    if @val.nil?
      @tag.to_s
    else
      { @tag => @val }
    end
  end

  # Initializes an instance of {{ data_type.name|class }} from
  # JSON-formatted data.
  def self.from_json(json)
    if json.is_a?(Hash)
      array = json.flatten
      if array.length != 2
        fail ArgumentError, "JSON should have one key/value pair."
      end
      tag = array[0].to_sym
    {% for field in data_type.all_fields %}
      if tag == :{{ field.name|variable }}
      {% if field.symbol %}
        val = nil
      {% elif field.data_type.composite_type %}
        val = {{ field.data_type.name|class }}.from_json(array[1])
      {% elif field.data_type.name == 'Timestamp' %}
        val = Dropbox::API::convert_date(array[1])
      {% elif field.data_type.name == 'List' and field.data_type.data_type.composite_type %}
        val = array[1].collect { |elem| {{field.data_type.data_type.name|class }}.from_json(array[1]) }
      {% else %}
        val = array[1]
      {% endif %}
      end
    {% endfor %}
    else
      # json is a String
      tag = json.to_sym
      val = nil
    end
    return self.new(tag, val)
  end
{% for field in data_type.all_fields %}

  # Initializes an instance of {{ data_type.name|class }} with the
  # {{ field.name|variable }} tag.
  def self.{{ field.name|method }}
    self.new(:{{ field.name|variable }})
  end

  # Checks if this union has the +{{ field.name|variable }}+ tag.
  def {{ field.name|method }}?
    @tag == :{{ field.name|variable }}
  end
  {% if not field.symbol %}

  # Retrieves the value for this union for the +{{ field.name|variable }}+
  # tag.
  def {{ field.name|method }}
    if @tag == :{{ field.name|variable }}
      @val
    else
      fail "Union is not this type."
    end
  end
  {% endif %}
{% endfor %}
end

{% endif -%}
{%- endfilter -%}
{%- endmacro %}


module Dropbox
  module API

    # Converts a string date to a Date object
    def self.convert_date(str)
      DateTime.strptime(str, '%a, %d %b %Y %H:%M:%S')
    end

    {% for namespace in api.namespaces.values() %}
        {% for data_type in namespace.data_types %}
          {{- object_def(data_type, 4) }}
        {% endfor %}
    {% endfor %}

    # This class is a wrapper around the Dropbox::API::FileInfo object that
    # provides some convenience methods for manipulating files. It includes
    # methods from the Dropbox::API::FileOps module.
    class File < FileInfo

      include FileOps

      attr_accessor :client

      def initialize(client, folder_info)
        super(*folder_info.instance_variables.collect do |name|
          a.instance_variable_get(name)
        end)
        @client = client
      end
    end

    # This class is a wrapper around the Dropbox::API::FolderInfo object that
    # provides some convenience methods for manipulating folders. It includes
    # methods from the Dropbox::API::FileOps module.
    class Folder < FolderInfo

      include FileOps

      attr_accessor :client

      class << self
        def create
          # TODO client method
        end
        alias_method :mkdir, :create
      end

      def initialize(client, folder_info)
        super(*folder_info.instance_variables.collect do |name|
          a.instance_variable_get(name)
        end)
        @client = client
      end
    end

  end
end