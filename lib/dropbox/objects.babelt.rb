# babelsdk(jinja2)

# DO NOT EDIT THIS FILE.
# This file is auto-generated from the babel template objects.babelt.rb.
# Any changes here will silently disappear into nothingness.

require 'date'

{%- macro docs(data_type) -%}
{% if data_type.doc %}
# {{ data_type.doc|wordwrap(70)|replace('\n', '\n# ') }}
#
{% endif %}
# Fields:
{% for field in data_type.all_fields %}
# * +{{ field.name }}+{% if field.data_type %} (+{{ field.data_type.name }}+){% endif %}
{% if field.doc %}:
#   {{ field.doc|wordwrap(70)|replace('\n', '\n#   ') }}
{% else %}
{# need a newline here #}

{% endif %}
{% endfor -%}
{%- endmacro -%}

{%- macro arg_list(args) -%}
{% for arg in args %}
{{ arg.name }}{% if arg.has_default %} = {{ arg.default|pprint }}{% elif arg.optional %} = nil{% endif %},
{% endfor %}
{%- endmacro -%}

###
{%- macro symbols(fields) -%}
{%- for field in fields -%}
{%- if field.symbol -%}
, :{{ field.name|method }}
{%- endif -%}
{%- endfor -%}
{%- endmacro -%}

###
{%- macro not_symbols(fields) -%}
{%- for field in fields -%}
{%- if not field.symbol -%}
, {{ field.name }}: {{ field.data_type.name }}
{%- endif -%}
{%- endfor -%}
{%- endmacro -%}

{%- macro object_def(data_type, indent_spaces) -%}
{%- filter indent(indent_spaces, indentfirst=True) -%}
{%- if data_type.composite_type == 'struct' and not data_type.name.endswith('Request') -%}
{{ docs(data_type) -}}
class {{ data_type.name|class }}{% if data_type.super_type %} < {{ data_type.super_type.name|class }}{% endif %}

  {% if data_type.fields %}
  attr_accessor(
      {{ data_type.fields|map(attribute='name')|map('inverse_format', ':{0}')|join(',\n      ') }}
  )
  {% endif %}

  def initialize(
      {{ arg_list(data_type.all_fields)|indent(6)|string_slice(0, -1) }}
  )
  {% for field in data_type.all_fields %}
    @{{ field.name }} = {{ field.name }}
  {% endfor %}
  end

  def self.from_json(json)
    self.new(
      {% for field in data_type.all_fields %}
        {%+ if field.nullable -%}
        json['{{ field.name }}'].nil? ? nil :{{ ' ' }}
        {%- elif field.optional -%}
        !json.include?('{{ field.name }}') ? nil :{{ ' ' }}
        {%- endif %}
        {% if field.data_type.composite_type -%}
        {{ field.data_type.name|class }}.from_json(json['{{ field.name }}']),
        {% elif field.data_type.name == 'Timestamp' -%}
        Dropbox::API::convert_date(json['{{ field.name }}']),
        {% elif field.data_type.name == 'List' and field.data_type.data_type.composite_type -%}
        json['{{ field.name }}'].collect { |elem| {{ field.data_type.data_type.name|class }}.from_json(elem) },
        {% else -%}
        json['{{ field.name }}'],
        {% endif %}
      {% endfor %}
    )
  end
end

{% elif data_type.composite_type == 'union' and not data_type.name.endswith('Error') -%}
{{ docs(data_type) -}}
class {{ data_type.name|class }}

  TYPES = [{{ data_type.all_fields|map(attribute='name')|map('inverse_format', ':{0}')|join(', ') }}]

  def initialize(key, val = nil)
    set(key, val)
  end

  def set(key, val = nil)
    if key.is_a?(String)
      key = key.to_sym
    end
    if key.is_a?(Symbol)
      if !TYPES.include?(key)
          fail ArgumentError, "Invalid symbol '#{ key }' for "\
            "this union. #{ TYPES }"
      end
    elsif key.is_a?(Hash)
      array = key.flatten
      if array.length != 2
        fail ArgumentError, 'Invalid JSON for this union.'
      end
      if !TYPES.include?(array[0].to_sym)
        fail ArgumentError, "Invalid key '#{ array[0] }' for this union."
      end
    else
      fail ArgumentError, "Argument must be a hash, string, or symbol."
    end
    @key = key
    @val = val
  end

  def value
    @val
  end

  def as_json(options = {})
    if @val.nil?
      @key.to_s
    else
      { @key => @val }
    end
  end

  def self.from_json(json)
    if json.is_a?(Hash)
      array = json.flatten
      if array.length != 2
        fail ArgumentError, "JSON should have one key/value pair."
      end
      key = array[0].to_sym
    {% for field in data_type.all_fields %}
      if key == :{{ field.name|variable }}
      {% if field.symbol %}
        val = nil
      {% elif field.data_type.composite_type %}
        val = {{ field.data_type.name|class }}.from_json(array[1])
      {% elif field.data_type.name == 'Timestamp' %}
        val = Dropbox::API::convert_date(array[1])
      {% elif field.data_type.name == 'List' and field.data_type.data_type.composite_type %}
        val = array[1].collect { |elem| {{field.data_type.data_type.name|class }}.from_json(array[1]) }
      {% else %}
        val = array[1]
      {% endif %}
      end
    {% endfor %}
    else
      # json is a String
      key = json.to_sym
      val = nil
    end
    return self.new(key, val)
  end
{% for field in data_type.all_fields %}

  def self.{{ field.name|method }}
    self.new(:{{ field.name|variable }})
  end

  def {{ field.name|method }}?
    @key == :{{ field.name|variable }}
  end

  def {{ field.name|method }}
    {% if field.symbol %}
    fail "This field is a symbol field."
    {% else %}
    if @key == :{{ field.name|variable }}
      @val
    else
      fail "Union is not this type."
    end
    {% endif %}
  end
{% endfor %}
end
{% endif -%}
{%- endfilter -%}
{%- endmacro %}

module Dropbox
  module API

    # Converts a string date to a Date object
    def self.convert_date(str)
      DateTime.strptime(str, '%a, %d %b %Y %H:%M:%S')
    end

    {% for namespace in api.namespaces.values() %}
        {% for data_type in namespace.data_types %}
          {{- object_def(data_type, 4) }}
        {% endfor %}
    {% endfor %}
  end
end